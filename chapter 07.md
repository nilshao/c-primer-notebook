## 类

类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现分离的编程技术，类的接口包括用户所能执行的操作：类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了他的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。类想要实现数据抽象和封装，首先需要定一个抽象数据类型，在抽象数据类型中，由类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽象地思考类型做了什么，而无需了解类型的工作细节。

### 定义抽象数据类型

在第一章中使用的Sales_item类是一个抽象数据类型，我们通过他的接口来使用一个Sales_item对象。我们不能访问Sales_item对象的数据成员，实际上，我们甚至根本不知道这个类有哪些数据成员。与之相反，Sales_data类不是一个抽象数据类型，它允许类的用户直接访问它的数据成员，并且要求由用户来编写操作，。要想把Sales_data变成抽象数据类型。我们需要定义一些操作以供类的用户使用。一旦Sales_data定义了他自己的操作，我们就可以封装(隐藏)他的数据成员了。

#### 设计Sales_data类

我们最终目的是令Sales_data支持与Sales_item类完全一样的操作集合，Sales_item类有一个名为isbn的成员函数，并且支持+,=,+=,>>和<<运算符。我们将在14章学习如何自定义运算符，现在我们先为这些运算定义普通的函数形式。执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义为普通函数：执行复合赋值运算的函数是成员函数，Sales_data类无需专门定义赋值运算。

综上所述，Sales_data的接口应包含以下操作：

+ 一个isbn成员函数，用于返回对象的ISBN编号
+ 一个combine成员函数，用于讲一个Sales_data对象加到另一个对象上
+ 一个名为add的函数，执行两个Sales_data对象的加法
+ 一个read函数，将数据从istream读入到Sales_data对象中
+ 一个print函数，将Sales_data对象的值输出到ostream

##### 使用改进的Sales_data类

在考虑如何实现我们的类之前，首先来看看应该如何使用上面这些接口函数，举个例子，我们使用这些函数编写书店程序的另外一个版本，其中不再使用Sales_item对象，而是使用Sales_data对象：

```C++
    Sales_data total;
    if(read(cin, total)){
        Sales_data trans;
        while(read(cin, trans)){
            if(total.isbn() == trans.isbn())
                total combine(trans);
            else{
                print(cout, total)<< endl;
                total = trans;
            }
        }
        print(cout, total) << endl;
    } else{
        cerr << "No data ?!" << endl;
    }
```

一开始我们定义了一个Sales_data对象用于保存实时的汇总信息，在if条件内部，调用read函数将第一条交易读入到total中，这里的条件部分与之前我们使用 >> 运算符的效果是一样的。 read函数返回它的流参数，而条件部分负责检查这个返回值，如果read函数失败，程序将直接跳转到else语句并输出一条错误信息。

如果检测到了读入数据，我们定义变量trans用于存放每一条交易。while语句的条件部分同样是检查read函数的返回值，只要输入操作成功，条件就被满足，意味着我们可以处理一条新的交易。

在while内部，我们分别调用total和trans的isbn成员以比较他们的ISBN编号

### 访问控制与封装

### 类的其它特性

### 类的作用域

### 构造函数再探

### 类的静态成员