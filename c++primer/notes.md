## 1. 第一章 开始

### 1.1. 编写一个简单的C++程序V

多个函数，其中1个必须是main函数。函数四个部分：返回类型，函数名，形参列表，函数体。main函数返回类型必须是int，函数返回值类型必须与函数的返回类型相容。

大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。

### 1.2. 初识输入输出

很多使用iosstream库，isstream和osstream分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语“流stream”想要表达的是，随着时间推移，字符是顺序生成或消耗的。

#### 1.2.1. 标准输入输出对象

4个IO对象，cin：标准输入。cout：标准输出。cerr：输出警告和错误消息，标准错误。clog：用于输出程序运行时的一般性信息。

#### 1.2.2. 一个使用IO库的程序

```C++
#include<iosstream>

int main(){
    std::cout<< "Enter 2 nums" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout<< "v1: "<<v1<<" v2: "<< v2<<std::endl;>
}

```

#### 1.2.3. 向流写入数据

略

#### 1.2.4. 使用标准库中的名字

std的命名空间(namespace)，::是作用域运算符

#### 1.2.5. 从流读取数据

输入运算符>>接收一个istream作为其左侧运算对象

### 1.3. 注释

略

### 1.4. 控制流

#### 1.4.1. while语句

```C++
while(condition)
    statement
```

前缀递增运算符(++i)

#### 1.4.2. for语句

#### 1.4.3. 读取数量不定的输入数据

```C++
#include <iostream>
int main(){
    int sum = 0, value = 0;
    while (std::cin >> value)
        sum += value;
    std::cout<< "sum is: " << sum << std::endl;
    return 0;
}
```

从标准输入读取下一个数，保存在value中。输入运算符返回其左侧运算对象，此例中是std::cin。使用istream对象作为条件时，其效果是检测流的状态，如果流是有效的，未遇到错误，则检测成功。若遇到文件结束符，或遇到无效输入时，istream对象变为无效，无效状态的istream对象会使条件变为假。

#### 1.4.4. if语句

### 1.5. 类简介

在C++中，我们通过定义一个类(class)来定义一个数据结构(data structure)。一个类定义了一个类型，以及与其关联的一组操作。三个问题：类名是什么，在哪里定义的，支持什么操作。

对于书店程序来说，假定类名Sales_item，头文件Sales_item.h中已经定义了这个类。使用标准库设施，必须包含相关头文件，类似的，也需要使用头文件来访问为自己的应用程序所定义的类，标准库头文件通常不带后缀。

#### 1.5.1. Sales_item类

Sales_item类定义了一个名为Sales_item的类型。与内置类型一样，我们可以定义类类型的变量。

```C++
    Sale_item item;
```

表达item是一个Sale_item类型的对象。除了定义Sales_item类型的变量之外，还可以：

+ 调用一个名为isbn的函数从一个Sales_item对象中提取ISBN书号
+ 用输入运算符(>>)和输出运算符(<<)读，写Sales_item类型的对象
+ 用赋值运算符(=)讲一个Sales_item对象的值赋予另一个Sales_item对象
+ 用加法运算符
+ 用复合赋值运算符

##### 读写Sales_item

##### Sales_item对象的加法

#### 1.5.2. 初识成员函数

将两个Sales_item对象相加的程序首先应该检查两个对象是否具有相同的ISBN：

```C++
#include <iostream>
#include "Sales_item.h"
int main(){
    Sales_item item1, item2;
    std::cin >> item1 >> item2;
    if(item1.isbn() == item2.isbn()){
        std::cout<< item1+item2 << std::endl;
        return 0;
    }else{
        std::cerr << "Data must refer to same ISBN" << std::endl;
        return -1;
    }
}

```

##### 什么是成员函数？

```
    item1.isbn() == item2.isbn();
```

调用了名为isbn的成员函数，成员函数是定义为类的一部分的函数。使用点运算符来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象，其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。当用点运算符访问一个成员函数时，通常我们是想调用该函数，我们使用调用运算符()，来调用一个函数，调用运算符是一对圆括号，里面放置实参列表（可能为空），本例中成员函数isbn不接受参数。

### 1.6. 书店程序

现在我们准备好完成书店程序：

我们需要从一个文件中读取销售记录，生成每本书的销售报告，显示售出册数，总销售额和平均售价，假设每个ISBN书豪的所有销售记录在文件中是聚在一起保存的。

我们的程序将每个ISBN所有数据合并起来，存入名为total的变量中，我们使用另一个名为trans## 2. 第二章 变量和基本类型

### 2.1. 基本内置类型

算数类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算数类型包含字符，整型，布尔值和浮点数。

#### 2.1.1. 算数类型

unsigned 类型所有比特都用来存储值

#### 2.1.2. 类型转换

将对象从一种给定类型convert为另一种相关类型。当我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。、

todo: 算数类型范围，带符号和无符号类型好好整理！！！

例子

```C++
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;       //假设char占8比特，c=255
signed char c2 = 256;       //假设char占8比特，c2的值是未定义的
```

后两个：

+ 当我们赋值给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 -1 mod 256 是255

+ 当我们赋值给带符号类型一个超出他表示范围的值时，结果是未定义的(undefined)，此时程序可能继续工作，可能崩溃也可能生成垃圾数据。

含有无符号类型的表达式

当一个算术表达式中又有int又有无符号数时，这个int就会被转换成无符号数，把int转换成无符号数的过程和把int直接赋值给无符号变量一样

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i + u << std::endl;
    std::cout << i + i << std::endl;
```

这与int在当前机器上所占位数决定，32位：4294967264即 2^32-32。

不要混用带符号类型和无符号类型

练习题！！

#### 2.1.3. 字面值常量literal

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

##### 2.1.3.1. 整形和浮点型字面值

十进制，八进制，十六进制。 以0开头的整数代表八进制，0x或0X开头的代表十六进制。十进制下的20：

20（十进制），024（八进制），0x14（十六进制）

整形字面值具体的数据类型由他的值和符号决定。默认情况下十进制字面值是带符号值，八进制和十六进制字面值既可能是带符号也可能是无符号的。十进制字面值类型是int, long, long long中尺寸最小的那个，前提是能容纳下。八进制和十六进制是int, unsigned int, long, unsigned long, long long, unsigned long long中最小的那个。如果容纳不下，将产生错误。类型short没有对应字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如-42的负十进制字面值，那个符号并不在字面值之内，他的作用是对字面值取负。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用e或E表示，如3.1415e0。

##### 2.1.3.2. 字符和字符串字面值

单引号字符，双引号字符串。 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符('\0')因此，字符串字面值的实际长度比它的内容多1。例如'A'表示单独的字符A，而"A"则代表了一个字符的数组，该数组包含两个字符：一个是字符A，另一个是空字符。

当两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，可以采取分开书写的方式。

##### 2.1.3.3. 转义序列

两类字符不能直接使用，一类是不可打印(nonprintable)的字符，如退格和其他控制字符，因为没有可视的图符。另一类是C++中有特殊含义的，需要转移序列，均由反斜线开始。

##### 2.1.3.4. 制定字面值的类型

通过添加前缀和后缀，可以改变整型，浮点型和字符型的字面值的默认类型。
P37！！！

##### 2.1.3.5. 布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针的字面值。

### 2.2. 变量

变量提供了一个具名的，可供操作的存储空间，C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间存储的值的范围，以及变量能参与的运算，变量variable和对象object一般可互换使用。

对象：具有某种数据类型的内存空间。

#### 2.2.1. 变量定义

类型说明符(type specifier), 随后一个或多个变量名组成的列表，其中变量名以逗号分隔，最终以分号结束。列表中每个变量名的类型都由类型说明符制定，定义时还可以为一个或多个变量定义初始值。在同一条语句中，可以用先定义的变量值去初始化后定义的其他变量

```c++
double price = 109.99, discount = price * 0.16;
```

初始化与赋值的区别：初始化是创建变量时赋予其一个初始值，而赋值的含义是把变量当前值擦除并用新值替代。

##### 2.2.1.1. 列表初始化

花括号初始化变量

```c++
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```

用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

```c++
    long double pi = 3.1415926;
    int a = {pi}, b{pi};            //报错
    int c = (pi), d = pi;           //正确
```

用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。

##### 2.2.1.2. 默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化(default initialized)，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

如果内置类型的变量未被显式初始化，它的值由定义的位置决定，定义于函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，试图拷贝或以其他形式访问此类值将引发错误。

#### 2.2.2. 变量声明和定义的关系

C++允许把程序拆分成多个逻辑部分来编写，支持分离式编译机制，该机制允许将程序分割成若干文件，每个文件可以独立编译。在文件之间共享代码，可能需要在一个文件使用另一个文件中定义的变量。

声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

```c++
    extern int i;       //声明i而非定义i
    int j;              //声明并定义j
```

任何包含了显式初始化的声明即成为定义，可以给由extern关键字标记的变量赋初始值，但是这么做也抵消了extern的作用。extern语句如果包含初始值就不再是声明而是定义了。在函数体内部，如果试图初始化一个extern关键字标记的变量将引发错误。

#### 2.2.3. 标识符

字母数字下划线，对大小写敏感，长度没有限制。C++保留关键字不能做identifier。

#### 2.2.4. 名字的作用域

不论在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量，函数，类型等。然而同一个名字如果出现在程序的不同位置，也可能是指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域都以花括号分隔。

全局作用域，块作用域，嵌套作用域

### 2.3. 复合类型

#### 2.3.1. 引用

“左值引用”，引用为对象起了另外一个名字，引用类型引用(refers to)另外一种类型 通过将声明符写成&d的形式来定义引用类型，其中d是生命的变量名。引用必须被初始化！初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时程序把引用和他的初始值绑定在一起而不是拷贝给引用。引用并非对象，他只是为一个已经存在的对象所起的另外一个名字。
（除了之后两种例外情况）所有引用类型都要和与之绑定的对象严格匹配，而且引用只能绑定在对象上而不能与字面值或某个表达式的计算结果绑定在一起。

```C++
    int &refVal = 10;               //wrong
    double pi = 3.14159;
    int &refVal1 = pi;              //wrong,引用类型的初始值必须也是int型
```

#### 2.3.2. 指针

指针是指向另外一种类型的符合类型。与引用的不同：

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针声明周期内他可以先后指向不同的对象

+ 指针无需在定义时赋初值，和其他内置类型一样，在块作用域中定义的指针如果没有初始化，也将拥有一个不确定的值
  
##### 2.3.2.1. 获取对象的地址

指针存放某个对象的地址，用取地址符获取该地址，指针的类型要和它所指向的对象严格匹配

```C++
    int ival = 42;
    int *p = &ival; //p存放ival的地址，或者说p是指向ival的指针

    double dval;
    double *pd = &dval;     //right
    double *pd2 = pd;       //right

    int *pi = pd;         //false,指针pi类型和pd类型不匹配
    pi = &dval;           //false,试图把double型对象的地址赋给int型指针
```

##### 2.3.2.2. 指针值

！！！！

##### 2.3.2.3. 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象。解引用符只适用于那些却是指向了某个对象的有效指针。注意*和&的多重含义

```C++
    int ival = 42;
    int *p = &ival;
    cout<< *p;

   int i = 42;
   int &r = i;                  //声明中的 引用
   int *p;                      //指针
   p = &i;                      //取地址符
   *p = i;                      //解引用
   int &r2 = *p;                //声明，解引用
```

##### 2.3.2.4. 空指针与初始化指针

！！！！

##### 2.3.2.5. 赋值和指针

##### 2.3.2.6. void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

```C++
    double obj = 3.14, *pd = &obj;
    void *pv = &obj;
    pv = pd;                        //pv可以存放任意类型的指针
```

不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。对void*来说，内存空间也就仅仅是内存空间，没办法访问其中所存的对象。

#### 2.3.3. 理解复合类型的声明

```C++
    int i = 1024, *p = &i, &r=i;
```

在同一条定义语句中，虽然基本数据类型只有一个，但是生命服的形势却可以不同，一条定义语句可以定义出不同类型的变量。

#### 2.3.4. 指向指针的指针

**表示指向指针的指针。

#### 2.3.5. 指向指针的引用

！！！！

### 2.4. const限定符

有时我们希望定义这样一种变量，他的值不能被改变。用关键字const对变量的类型进行限定。

const对象一旦创建之后其值就不能在改变，所以const对象必须初始化，初始值可以是任意表达式。任何试图在之后复制的行为都将会引发错误、

```C++
    const int bufSize = 512;

    bufSize = 512;                  //报错
```

默认状态下，const对象仅在文件内有效。可以在一个文件中定义const，在其他多个文件中声明并使用，应该对于const变量的声明和定义，都添加extern关键字。

#### 2.4.1. const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对敞亮的引用不能被用做修改他说不能绑定的对象。

```C++
    const int ci = 1024;            // right
    const int &rl = ci;             // right
    rl = 42;                        // wrong
    int &r2 = ci;                   // wrong 不能让一个非常量的引用指向一个常量对象
```

！！！

### 2.5. 处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两方面。一是一些类型难于拼写，他们的名字既难记又容易拼错，还无法明确体现其真实目的和含义。二是有时候根本搞不清需要的类型是什么。

#### 2.5.1. 类型别名

类型别名是一个名字，它是某种类型的同义词，他让复杂的类型名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
传统方法是typedef:

```C++
    typedef double wages;           //wages是double的同义词
    typedef wages base, *p;         //base是double的同义词，p是double*的同义词
```

新标准，使用别名声明

```C++
    using SI = Sales_item;          // SI是Sales_item的同义词
```

指针，常量和类型别名：

#### 2.5.2. auto类型说明符

有时在声明变量的时候不能清楚地知道表达式的类型，C++引入auto类型说明符，用它可以让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(如double)不同，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。

#### 2.5.3. decltype类型指示符

### 2.6. 自定义数据结构

#### 定义Sales_data类型

简单的类：用户能直接访问其中的数据元素，也能实现一些基本的操作。不妨命名为Sales_data类：

```C++
struct Sales_data(){
    std::string bookNO;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```

以关键字struct开始，紧跟着类名和类体，类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。类体右侧的表示结束的花括号后必须跟一个分号，这是因为类体后面可以紧跟变量名，以示对该类型对象的定义。不过不被建议

##### 类数据成员

类体定义类的成员，我们这个类只有数据成员，类的数据成员定义了类的对象的具体内容，定义数据成员的方法和定义普通变量一样，首先说明一个基本类型，随后紧跟一个或多个声明符，我们的类有3个数据成员：一个名为bookNo的string成员，etc，每个Sales_data的对象都将包括这三个数据成员。

可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始值得成员将被默认初始化。

#### 使用Sales_data类

##### 添加两个Sales_data对象

在前面介绍的Sales_data类中没有提供任何操作，所以我们必须自己编码实现输入，输出和相加的功能。

##### Sales_data对象写入数据

##### 输出两个Sales_data的和

#### 编写自己的头文件

尽管可以在函数体内定义类，但是这样的类收到了一些限制，所以类一般都不在函数体内。

几个注意事项

##### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器，是在编译之前执行的一段程序，可以部分地改变我们所写的程序。#include是一种预处理功能，当预处理器看到#include 标记时就会用指定的头文件的内容代替#include。

另一种预处理功能是头文件保护符，#define，#ifdef(#endif)。## 2. 第二章 变量和基本类型

### 2.1. 基本内置类型

算数类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算数类型包含字符，整型，布尔值和浮点数。

#### 2.1.1. 算数类型

unsigned 类型所有比特都用来存储值

#### 2.1.2. 类型转换

将对象从一种给定类型convert为另一种相关类型。当我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。、

todo: 算数类型范围，带符号和无符号类型好好整理！！！

例子

```C++
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;       //假设char占8比特，c=255
signed char c2 = 256;       //假设char占8比特，c2的值是未定义的
```

后两个：

+ 当我们赋值给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 -1 mod 256 是255

+ 当我们赋值给带符号类型一个超出他表示范围的值时，结果是未定义的(undefined)，此时程序可能继续工作，可能崩溃也可能生成垃圾数据。

含有无符号类型的表达式

当一个算术表达式中又有int又有无符号数时，这个int就会被转换成无符号数，把int转换成无符号数的过程和把int直接赋值给无符号变量一样

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i + u << std::endl;
    std::cout << i + i << std::endl;
```

这与int在当前机器上所占位数决定，32位：4294967264即 2^32-32。

不要混用带符号类型和无符号类型

练习题！！

#### 2.1.3. 字面值常量literal

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

##### 2.1.3.1. 整形和浮点型字面值

十进制，八进制，十六进制。 以0开头的整数代表八进制，0x或0X开头的代表十六进制。十进制下的20：

20（十进制），024（八进制），0x14（十六进制）

整形字面值具体的数据类型由他的值和符号决定。默认情况下十进制字面值是带符号值，八进制和十六进制字面值既可能是带符号也可能是无符号的。十进制字面值类型是int, long, long long中尺寸最小的那个，前提是能容纳下。八进制和十六进制是int, unsigned int, long, unsigned long, long long, unsigned long long中最小的那个。如果容纳不下，将产生错误。类型short没有对应字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如-42的负十进制字面值，那个符号并不在字面值之内，他的作用是对字面值取负。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用e或E表示，如3.1415e0。

##### 2.1.3.2. 字符和字符串字面值

单引号字符，双引号字符串。 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符('\0')因此，字符串字面值的实际长度比它的内容多1。例如'A'表示单独的字符A，而"A"则代表了一个字符的数组，该数组包含两个字符：一个是字符A，另一个是空字符。

当两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，可以采取分开书写的方式。

##### 2.1.3.3. 转义序列

两类字符不能直接使用，一类是不可打印(nonprintable)的字符，如退格和其他控制字符，因为没有可视的图符。另一类是C++中有特殊含义的，需要转移序列，均由反斜线开始。

##### 2.1.3.4. 制定字面值的类型

通过添加前缀和后缀，可以改变整型，浮点型和字符型的字面值的默认类型。
P37！！！

##### 2.1.3.5. 布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针的字面值。

### 2.2. 变量

变量提供了一个具名的，可供操作的存储空间，C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间存储的值的范围，以及变量能参与的运算，变量variable和对象object一般可互换使用。

对象：具有某种数据类型的内存空间。

#### 2.2.1. 变量定义

类型说明符(type specifier), 随后一个或多个变量名组成的列表，其中变量名以逗号分隔，最终以分号结束。列表中每个变量名的类型都由类型说明符制定，定义时还可以为一个或多个变量定义初始值。在同一条语句中，可以用先定义的变量值去初始化后定义的其他变量

```c++
double price = 109.99, discount = price * 0.16;
```

初始化与赋值的区别：初始化是创建变量时赋予其一个初始值，而赋值的含义是把变量当前值擦除并用新值替代。

##### 2.2.1.1. 列表初始化

花括号初始化变量

```c++
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```

用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

```c++
    long double pi = 3.1415926;
    int a = {pi}, b{pi};            //报错
    int c = (pi), d = pi;           //正确
```

用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。

##### 2.2.1.2. 默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化(default initialized)，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

如果内置类型的变量未被显式初始化，它的值由定义的位置决定，定义于函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，试图拷贝或以其他形式访问此类值将引发错误。

#### 2.2.2. 变量声明和定义的关系

C++允许把程序拆分成多个逻辑部分来编写，支持分离式编译机制，该机制允许将程序分割成若干文件，每个文件可以独立编译。在文件之间共享代码，可能需要在一个文件使用另一个文件中定义的变量。

声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

```c++
    extern int i;       //声明i而非定义i
    int j;              //声明并定义j
```

任何包含了显式初始化的声明即成为定义，可以给由extern关键字标记的变量赋初始值，但是这么做也抵消了extern的作用。extern语句如果包含初始值就不再是声明而是定义了。在函数体内部，如果试图初始化一个extern关键字标记的变量将引发错误。

#### 2.2.3. 标识符

字母数字下划线，对大小写敏感，长度没有限制。C++保留关键字不能做identifier。

#### 2.2.4. 名字的作用域

不论在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量，函数，类型等。然而同一个名字如果出现在程序的不同位置，也可能是指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域都以花括号分隔。

全局作用域，块作用域，嵌套作用域

### 2.3. 复合类型

#### 2.3.1. 引用

“左值引用”，引用为对象起了另外一个名字，引用类型引用(refers to)另外一种类型 通过将声明符写成&d的形式来定义引用类型，其中d是生命的变量名。引用必须被初始化！初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时程序把引用和他的初始值绑定在一起而不是拷贝给引用。引用并非对象，他只是为一个已经存在的对象所起的另外一个名字。
（除了之后两种例外情况）所有引用类型都要和与之绑定的对象严格匹配，而且引用只能绑定在对象上而不能与字面值或某个表达式的计算结果绑定在一起。

```C++
    int &refVal = 10;               //wrong
    double pi = 3.14159;
    int &refVal1 = pi;              //wrong,引用类型的初始值必须也是int型
```

#### 2.3.2. 指针

指针是指向另外一种类型的符合类型。与引用的不同：

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针声明周期内他可以先后指向不同的对象

+ 指针无需在定义时赋初值，和其他内置类型一样，在块作用域中定义的指针如果没有初始化，也将拥有一个不确定的值
  
##### 2.3.2.1. 获取对象的地址

指针存放某个对象的地址，用取地址符获取该地址，指针的类型要和它所指向的对象严格匹配

```C++
    int ival = 42;
    int *p = &ival; //p存放ival的地址，或者说p是指向ival的指针

    double dval;
    double *pd = &dval;     //right
    double *pd2 = pd;       //right

    int *pi = pd;         //false,指针pi类型和pd类型不匹配
    pi = &dval;           //false,试图把double型对象的地址赋给int型指针
```

##### 2.3.2.2. 指针值

！！！！

##### 2.3.2.3. 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象。解引用符只适用于那些却是指向了某个对象的有效指针。注意*和&的多重含义

```C++
    int ival = 42;
    int *p = &ival;
    cout<< *p;

   int i = 42;
   int &r = i;                  //声明中的 引用
   int *p;                      //指针
   p = &i;                      //取地址符
   *p = i;                      //解引用
   int &r2 = *p;                //声明，解引用
```

##### 2.3.2.4. 空指针与初始化指针

！！！！

##### 2.3.2.5. 赋值和指针

##### 2.3.2.6. void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

```C++
    double obj = 3.14, *pd = &obj;
    void *pv = &obj;
    pv = pd;                        //pv可以存放任意类型的指针
```

不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。对void*来说，内存空间也就仅仅是内存空间，没办法访问其中所存的对象。

#### 2.3.3. 理解复合类型的声明

```C++
    int i = 1024, *p = &i, &r=i;
```

在同一条定义语句中，虽然基本数据类型只有一个，但是生命服的形势却可以不同，一条定义语句可以定义出不同类型的变量。

#### 2.3.4. 指向指针的指针

**表示指向指针的指针。

#### 2.3.5. 指向指针的引用

！！！！

### 2.4. const限定符

有时我们希望定义这样一种变量，他的值不能被改变。用关键字const对变量的类型进行限定。

const对象一旦创建之后其值就不能在改变，所以const对象必须初始化，初始值可以是任意表达式。任何试图在之后复制的行为都将会引发错误、

```C++
    const int bufSize = 512;

    bufSize = 512;                  //报错
```

默认状态下，const对象仅在文件内有效。可以在一个文件中定义const，在其他多个文件中声明并使用，应该对于const变量的声明和定义，都添加extern关键字。

#### 2.4.1. const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对敞亮的引用不能被用做修改他说不能绑定的对象。

```C++
    const int ci = 1024;            // right
    const int &rl = ci;             // right
    rl = 42;                        // wrong
    int &r2 = ci;                   // wrong 不能让一个非常量的引用指向一个常量对象
```

！！！

### 2.5. 处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两方面。一是一些类型难于拼写，他们的名字既难记又容易拼错，还无法明确体现其真实目的和含义。二是有时候根本搞不清需要的类型是什么。

#### 2.5.1. 类型别名

类型别名是一个名字，它是某种类型的同义词，他让复杂的类型名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
传统方法是typedef:

```C++
    typedef double wages;           //wages是double的同义词
    typedef wages base, *p;         //base是double的同义词，p是double*的同义词
```

新标准，使用别名声明

```C++
    using SI = Sales_item;          // SI是Sales_item的同义词
```

指针，常量和类型别名：

#### 2.5.2. auto类型说明符

有时在声明变量的时候不能清楚地知道表达式的类型，C++引入auto类型说明符，用它可以让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(如double)不同，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。

#### 2.5.3. decltype类型指示符

### 2.6. 自定义数据结构

#### 定义Sales_data类型

简单的类：用户能直接访问其中的数据元素，也能实现一些基本的操作。不妨命名为Sales_data类：

```C++
struct Sales_data(){
    std::string bookNO;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```

以关键字struct开始，紧跟着类名和类体，类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。类体右侧的表示结束的花括号后必须跟一个分号，这是因为类体后面可以紧跟变量名，以示对该类型对象的定义。不过不被建议

##### 类数据成员

类体定义类的成员，我们这个类只有数据成员，类的数据成员定义了类的对象的具体内容，定义数据成员的方法和定义普通变量一样，首先说明一个基本类型，随后紧跟一个或多个声明符，我们的类有3个数据成员：一个名为bookNo的string成员，etc，每个Sales_data的对象都将包括这三个数据成员。

可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始值得成员将被默认初始化。

#### 使用Sales_data类

##### 添加两个Sales_data对象

在前面介绍的Sales_data类中没有提供任何操作，所以我们必须自己编码实现输入，输出和相加的功能。

##### Sales_data对象写入数据

##### 输出两个Sales_data的和

#### 编写自己的头文件

尽管可以在函数体内定义类，但是这样的类收到了一些限制，所以类一般都不在函数体内。## 6. 函数

### 6.1. 函数基础

一个典型的函数定义包括以下部分，返回类型，函数名字，由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，函数执行的操作在块中说明，该块称为函数体。

通过调用运算符来执行参数，调用运算符的形式是一对圆括号，他作用于一个表达式，该表达式是函数或者指向函数的指针，圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型是函数的返回类型。

函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数，此时，主调函数的执行被暂时中断，被调函数开始执行。执行函数的第一步是隐式地定义并初始化他的形参，

当遇到return语句时函数结束执行过程，和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如过有），二是将控制权从被调函数转移回主调函数，函数的返回值可能作用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。

##### 函数调用

函数调用完成两项工作：一是用实参初始化函数的形参，二是将控制权转移给被调函数。此时，主调函数的执行被暂时中断，被调函数开始执行

##### 形参和实参

实参是形参的初始值，第一个实参初始化第一个形参，第二个实参初始化第二个形参，（用实参初始化函数的形参）以此类推。尽管实参与形参存在对应关系，但是没有规定实参的求值顺序，编译器可以任意可行的顺序对实参求值。

实参的类型必须与相对应的形参类型和数量匹配，因为函数调用规定实参数量与形参数量一致，所以形参一定会被初始化。

##### 函数的形参列表

函数的形参列表可以为空，但不可省略，要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表，也可以用void表示函数没有形参。

```C++
    void f1(){}
    void f2(void){}
```

任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。形参名是可选的，但是由于我们无法使用未命名的形参，所以形参一般都应该有个名字。即使某个形参不被函数体使用，也必须提供实参。


##### 函数返回类型

大多数类型都能用作函数的返回类型，一种特殊的返回类型是void，它表示函数不能返回任何值，函数的返回类型不能是数组类型或函数类型。但是可以是指向数组和函数的指针，6.3.3中介绍如何定义一种特殊的函数，他的返回值是数组的指针或引用，6.7中介绍如何返回指向函数的指针。

#### 局部对象

局部对象：

自动对象：

局部静态对象：

在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止时蔡晓辉，此期间即使对象所在的函数结束执行也不会对他有影响

### 6.2. 参数传递

如前所述，每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。和其他变量一样，形参的类型决定了形参和实参交互的方式，如果形参是引用类型，它将绑定到对应的实参上，否则，将实参的值拷贝后赋给形参。

当形参是引用类型时，我们说它对应的参数被引用传递或者函数被传引用调用，和其他引用一样，引用形参也是它绑定的对象的别名，也就是说，引用形参是它对应的实参的别名。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，我们说这样的实参被值传递，或者函数被传值调用。

#### 6.2.1. 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时，对变量的改动不会影响初始值。

##### 指针形参

指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。因为值真实我们可以间接地访问它所指的对象，所以通过指针可以修改他所值对象的值。

#### 6.2.2. 传引用参数

回忆过去所学的知识，我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之相似，通过使用引用形参，允许函数改变一个或多个实参的值，引用形参绑定初始化它的对象，所以函数体中被改变的是传入它的实参。

##### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作，当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。
举例：我们准备比较两个string长度，而string对象可能非常长，所以应该尽量避免直接拷贝他们，这时使用引用形参是比较明智的选择，而且比较长度无需改变string对象的内容。

##### 使用引用返回额外信息

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径，举个例子，我们定义一个名为

！！！

#### const形参和实参

当形参是const时，要注意关于顶层const的讨论，如前所述，顶层const作用于对象本身。

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const，换句话说，形参的顶层const被忽略掉了，当形参有顶层const时，传给他常量对象或者非常量对象都是可以的

##### 指针或引用形参与const

##### 尽量使用常量引用

把函数不会改变的形参定义成普通的引用是一种比较常见的错误。这么做会带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接收的实参类型，例如我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用实参。例如：

```C++
    string::size_type find_char(string &s,char c, string::size_type &occurs);
```

则只能将find_char函数作用于string对象，类似下面这样的调用将在编译时发生错误

```
    find_char("hello world", 'o', ctr);
```

还有一个更难发觉的错误，假如其他函数正确地将他们的形参定义成常量引用，那么第二个版本的find_char无法在此类函数中正常使用，例子：我们希望在一个判断string对象是否是句子的函数中使用find_char:

```C++
bool is_sentence(const string &s){
    string::size_type ctr = 0;
    return find_char(s,'.',ctr)==s.size()-1 && ctr == 1;
}
```

如果find_char的第一个形参类型时string&，那么上面这条调用find_char的语句将在编译时发生错误，原因在于s是常量引用，但find_char被不正确地定义成只能接收普通引用。解决该问题的一种思路是修改is_sentence的形参类型，但只是转移了错误而已，结果是is_sentence函数的调用者只能接受非常量string对象。

正确的修改思路是改正find_char函数的形参，或者在is_sentence中定义一个string类型的变量，令其为s的副本，然后把这个string对象传递给find_char。

#### 数组形参

数组两个特殊性质对于我们定义和使用作用在数组上的函数有影响，这两个性质是不允许拷贝数组，以及使用数组时通常会将其转换成指针。因为不能拷贝数组，所以我们不能以值传递的方式使用数组参数，因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上给传递的是指向数组是指向数组首元素的指针。可以把形参写成类似数组的形式。

``` C++
    void print(const int*);
    void print(const int[]);
    void print(const int[10]);
```

#### main函数处理命令行选项

main函数是演示c++程序如何向函数传递数组的好例子。到目前为止，我们定义的main函数都只有空形参列表：

```C++
    int main(){}
```

然而，有时候我们确实需要给main函数传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定main函数位于可执行文件prog之内，我们可以像程序传递下面的选项：

```C++
    prog -d -o ofile data0
```

这些命令行选项通过两个可选的形参传递给main函数

```C++
    int main(int argc, char *argv[]){...}
```

第二个形参argv是一个数组，他的元素是指向c风格字符串的指针：第一个形参argc表示数组中字符串的数量，因为第二个形参是数组，所以main函数也可以定义成：

```C++
    int main(int argc, char **argv)
```

其中argv指向char*。
当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

例子：argc等于5，argv则应包含如下的c风格字符串：

```c++
    argv[0] = "prog";
    argv[1] = "-d";
    argv[2] = "-o";
    argv[3] = "ofile";
    argv[4] = "data0";
    argv[5] = 0;
```

#### 含有可变形参的函数

有时无法提前预知应该向函数传递几个实参。例如我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该功能，以便对所有错误的处理能够整齐划一，然而错误信息的种类不同，所以调用错误输出函数时传递的实参也各不相同。

省略符形参，可以传递可变数量的实参，不过需要注意的是一般只用于与c函数交互的接口程序。

##### initializer_list形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的实参，用于表示某种特定类型的值的数组

### 6.3. 返回类型和return语句

两种形式

```C++
    return ;
    return expression;
```

### 6.4. 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数，这些函数接受的形参类型不一样，但是执行的操作非常类似。调用这些函数时，编译器根据传递的实参类型推断想要的是哪个函数。函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻起名字记名字的负担。

##### 定义重载函数

有一种典型的数据库应用，需要创建几个不同的函数分别根据名字，电话，账户号码等信息查找记录，函数重载使得我们可以定义一组函数，它们的名字都是lookup，但是查找的依据不同，我们能通过以下形式中的任意一种调用lookup函数：

```C++
    Record lookup(const Account&);
    Record lookup(const Phone&);
    Record lookup(const Name&);
    Account acct;
    Phone phone;
    Record r1 = lookup(acct);
    Record r2 = lookup(phone);
```

其中，虽然我们定义的三个函数各不相同，但它们都有同一个名字。编译器根据实参的类型确定应该调用哪一个函数。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。在上面的代码中，虽然每个函数都只接受一个函数，但是参数的类型不同。不允许两个函数除了返回类型外其他所有的要素都相同，假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的。

```C++
    Record lookup(const Account&)
    bool lookup(const Account&)     //错误
```

##### 判断两个形参的类型是否相异

有的时候两个形参列表看起来不同但实际上相同，
！！！

##### 重载和const形参

顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```C++
    Record lookup(Phone);
    Record lookup(const Phone);

    Record lookup(Phone*);
    Record lookup(Phone* const);
```

在这两组函数声明中，每一组的第二个生命和第一个是一样的。另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```C++

```

##### 调用重载的函数

定义了一组重载函数后，我们需要以合理的实参调用它们。函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫重载确定。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

重载调用的三种结果：找到最佳匹配并调用，无匹配，二义性调用。

#### 重载与作用域

如果在内层作用域中声明函数名，他将隐藏外层作用域中声明的同名实体，在不同作用域中无法重载函数名。

### 6.5. 特殊用途语言特性

#### 默认实参

某些函数有这样一种形参，在函数的很多次调用中他们都被赋予一个相同的值，此时我们把这个反复出现的值称为函数的默认实参，调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

！！！ 一旦某个形参被赋予了默认值，他后面所有形参都必须有默认值。

##### 使用默认实参调用函数

想使用默认实餐，只要在调用函数的时候省略该实参。函数调用时实参按照其位置解析，默认实参负责填补函数调用缺少的尾部实参。（只能省略尾部实参）

##### 默认实参声明。

对于函数声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是对于多次声明同一个函数也是合法的，不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参，换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，切改形参右侧的所有形参都必须有默认值

##### 默认实参初始值

局部变量不能作为默认实参，声明必须出现在函数之外

#### 内联函数和constexpr

把小规模操作定义为函数有好处，但是一次函数调用包括一系列工作：调用前保存寄存器，并在返回时恢复，可能要拷贝实参，程序转向一个新的位置继续执行

##### 内联函数

将函数定义为内联函数（inline），通常就是将他在每个调用点上内联地展开，从而消除了函数运行时的开销。在函数返回类型前加上关键字inline

#### 调试帮助

assert和NDEBUG：

##### assert

在cassert头文件中

##### NDEBUG

### 6.6. 函数匹配

几个重载函数的形参数量相等以及某些形参的类型可以有其他类型转换得来时，重载调用问题。

```C++
    void f();
    void f(int);
    void f(double,double=3.14);
    void f(int, int);

    f(5.6);         //调用
```

##### 确定候选函数和可行函数

1. 选定本次调用对应的重载函数集，集合中的函数称为候选函数。

2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，称为候选函数

##### 寻找最佳匹配

3. 从可行函数中选择与本次调用最匹配函数，在此过程中逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

基本思想是实参类型与形参类型越接近，他们匹配的越好。

### 6.7. 函数指针

函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：

```C++
    bool lengthCompare(const string & , const string &);    //比较两个string对象的长度
```

该函数的类型是bool，要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。

```C++
    bool (*pf) (const string & , const string &)
    //pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
```

pf是指针，右侧是形参列表,表示pf指向的是函数，再观察左侧，发现函数的返回类型的布尔值，因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

pf两端的括号必不可少，少了括号，pf是一个返回值为bool指针的的函数，返回值是bool*。

##### 使用函数指针

当我们## 类

类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现分离的编程技术，类的接口包括用户所能执行的操作：类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了他的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。类想要实现数据抽象和封装，首先需要定一个抽象数据类型，在抽象数据类型中，由类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽象地思考类型做了什么，而无需了解类型的工作细节。

### 定义抽象数据类型

在第一章中使用的Sales_item类是一个抽象数据类型，我们通过他的接口来使用一个Sales_item对象。我们不能访问Sales_item对象的数据成员，实际上，我们甚至根本不知道这个类有哪些数据成员。与之相反，Sales_data类不是一个抽象数据类型，它允许类的用户直接访问它的数据成员，并且要求由用户来编写操作，。要想把Sales_data变成抽象数据类型。我们需要定义一些操作以供类的用户使用。一旦Sales_data定义了他自己的操作，我们就可以封装(隐藏)他的数据成员了。

#### 设计Sales_data类

我们最终目的是令Sales_data支持与Sales_item类完全一样的操作集合，Sales_item类有一个名为isbn的成员函数，并且支持+,=,+=,>>和<<运算符。我们将在14章学习如何自定义运算符，现在我们先为这些运算定义普通的函数形式。执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义为普通函数：执行复合赋值运算的函数是成员函数，Sales_data类无需专门定义赋值运算。

综上所述，Sales_data的接口应包含以下操作：

+ 一个isbn成员函数，用于返回对象的ISBN编号
+ 一个combine成员函数，用于讲一个Sales_data对象加到另一个对象上
+ 一个名为add的函数，执行两个Sales_data对象的加法
+ 一个read函数，将数据从istream读入到Sales_data对象中
+ 一个print函数，将Sales_data对象的值输出到ostream

##### 使用改进的Sales_data类

在考虑如何实现我们的类之前，首先来看看应该如何使用上面这些接口函数，举个例子，我们使用这些函数编写书店程序的另外一个版本，其中不再使用Sales_item对象，而是使用Sales_data对象：

```C++
    Sales_data total;
    if(read(cin, total)){
        Sales_data trans;
        while(read(cin, trans)){
            if(total.isbn() == trans.isbn())
                total.combine(trans);
            else{
                print(cout, total)<< endl;
                total = trans;
            }
        }
        print(cout, total) << endl;
    } else{
        cerr << "No data ?!" << endl;
    }
```

一开始我们定义了一个Sales_data对象用于保存实时的汇总信息，在if条件内部，调用read函数将第一条交易读入到total中，这里的条件部分与之前我们使用 >> 运算符的效果是一样的。 read函数返回它的流参数，而条件部分负责检查这个返回值，如果read函数失败，程序将直接跳转到else语句并输出一条错误信息。

如果检测到了读入数据，我们定义变量trans用于存放每一条交易。while语句的条件部分同样是检查read函数的返回值，只要输入操作成功，条件就被满足，意味着我们可以处理一条新的交易。

在while内部，我们分别调用total和trans的isbn成员以比较他们的ISBN编号。如果total和trans知识的是同一本书，我们调用

#### 定义改进的Sales_data类

##### 定义成员函数



#### 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数，任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同，但是没有返回类型，除此之外类似于其他的函数，构造函数也有一个可能为空的参数列表和一个函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。不同于其他成员函数，构造函数不能被声明成const的，当我们创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数在const对象的构造过程中可以向其写值。

##### 合成的默认构造函数

##### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合很简单的类，比如这个Sales_data版本，对于一个普通的类来说，必须定义它自己的默认构造函数，三个原因：一是编译期只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。

#### 拷贝，赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝，赋值和销毁对象时发生的行为，对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象等，当我们使用赋值运算符时会发生对象的赋值操作，当对象不再存在时将执行销毁操作，比如一个局部对象会在创建它的块结束时被销毁，当vector对象销毁时存储在其中的对象也会被销毁。

如果我们不主动定义这些操作，则编译器将替我们合成他们。

##### 某些类不能依赖于合成的版本

对于某些类来说合成的版本无法正常工作，特别是当类需要分配类对象之外的资源时，合成的版本常常会失效。12章将介绍C++程序是如何分配和管理动态内存的，13.1.4中我们将会看到，管理动态内存的类通常不能依赖与上述操作的合成版本。

### 访问控制与封装

我们已经定义了接口，但是没有封装，用户可以直达Sales_data对象的内部并且控制它的具体实现细节，用访问说明符加强类的封装性。

+ 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
+ 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装(即隐藏了)类的实现细节

修改后的新形式：

```C++
class Sales_data{
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
        bookNo(s), units_sold(n), revenue(p*n){}
    Sales_data(const std::string &s: bookNo(s)){}
    Sales_data(std::istream&);
    std::string isbn() const {return bookNo;}
    Sales_data &combine(const Sales_data&);
private:
    double avg_price() const{
        return units_sold ? revenue/units_sold : 0;
    }
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格规定，每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

##### class 和 struct 关键字

struct和class的默认访问权限不太一样。类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式，如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的，相反，如果是class关键字，这些成员是private的。因此当我们希望定义的类的所有成员是public时，使用struct，反之，如果希望成员是private的，使用class。

#### 友元

private的数据成员，print,add,read无法正常编译了，因为他们是类的一部分，但不是类的公有成员。类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他的友元，如果类想把一个函数作为他的友元，只需要增加一条以friend关键字开始的函数声明语句。

```C++
class Sales_data{
//为 Sales_data 的非成员函数所做的友元声明
friend Sales_data add(const Sales_data& , const Sales_data&);
friend std::istream &read(std::istream&, Sales_data& );
friend std::ostream &print(std::ostream&, const Sales_data&);

public:
    // ...
private:
    // ...
};
//Sales_data接口的非成员组成部分的声明
friend Sales_data add(const Sales_data& , const Sales_data&);
friend std::istream &read(std::istream&, Sales_data& );
friend std::ostream &print(std::ostream&, const Sales_data&);
```

友元声明只能出现在类定义的内部但是具体位置不限。

##### 友元的声明

### 类的其它特性

### 类的作用域

### 构造函数再探

### 类的静态成员## 第十章 泛型算法

一些可以用于不同类型的元素和多种容器类型的算法

### 概述

大多数定义在头文件algorithm中，还有numeric等。

一般情况下这些算法并不直接操作容器，而是编理由两个迭代器指定的一个元素范围，如标准库算法find，可用于vector，find，数组等。

##### 算法如何工作

工作过程

##### 迭代器算法不依赖于容器

##### 但算法依赖于元素类型的操作

虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个或多个元素类型上的操作。如find用元素类型的==运算符完成每个元素与给定值的比较，其他算法可能要求元素类型支持<运算符。