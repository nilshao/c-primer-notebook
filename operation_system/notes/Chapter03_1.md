# 第三章 第一节 内存

## 内存概念

内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理

于是：在多道程序环境下，系统中多个进程并发执行，多个程序的数据需要同时放到内存中，如何区分各个程序的数据需要放到什么地方？

方法：给内存的存储单元变地址，内存地址从0开始，每个地址对应一个存储单元

如果计算机”按字节编址“，则每个存储单元大小为一字节，1B，即8个二进制位

如果”按字编址“，每个存储单元大小为1个字，字长十六位的计算机中每个字的大小为16个二进制位。


![内存介绍1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/内存介绍1.jpeg)

## 进程的运行原理：指令

![指令](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/指令.jpeg)

相对地址=逻辑地址，绝对地址=物理地址


## 从写程序到运行

![从写程序到运行](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/从写程序到运行.jpeg)

装入模块中的地址指的是“相对地址”，但是装入模块装入内存时，需要对指令中的地址进行处理。装入的三种方式（由三种不同的方法完成逻辑地址到物理地址的转换）：

1. 绝对装入 
2. 静态重定位
3. 动态重定位


### 绝对装入

在编译时，如果知道程序将放入内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

绝对装入只适用于单道程序环境。程序中使用的绝对地址可以在编译或汇编时给出，也可由程序猿直接赋予。

### 静态重定位

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址。

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存就不能再移动，也不能再申请内存空间。

### 动态重定位

动态重定位又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行，这种方式需要一个重定位寄存器的支持。

采用动态重定位时允许程序在内存中发生移动。并且可以将程序分配到不连续的存储区中，在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。


## 内存管理

* 操作系统负责内存的分配和回收

* 操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟内存）

* 操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换

* 操作系统提供内存保护功能，保证各个进程在各自存储空间内运行，互不干扰

	内存保护两种方法：

	1. 在cpu中设置一堆上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，cpu检查是否越界

	2. 重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查，分别存放起始地址和长度

## 内存空间的扩充：覆盖和交换

![覆盖和交换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖和交换.jpeg)

### 覆盖技术

思想：把程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时放入内存。需要常驻内存的段放在固定区，不常用的段放在覆盖区。内存中分为一个固定区和多个覆盖区。

![覆盖技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖技术.jpeg)

### 交换技术

内存空间紧张时，系统将内存中某些进程暂时换出到外存，把外存中某些已具备运行条件的进程换入到内存


暂时换出到外存等待的进程状态为挂起状态suspend

挂起状态可进一步细分为就绪挂起和阻塞挂起

问题：

1. 应该在外存的什么位置保存被换出的进程？

2. 什么时候交换？

3. 换出哪些进程？

（补全文字）

![交换技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/交换技术.jpeg)

1. 具有兑换功能的操作系统中，通常把磁盘空间分为文件区和对换区

2. 

3. 

但是pcb会常驻内存，不会被换出外存

## 连续分配式管理

连续分配：为用户进程分配的必须是一个连续的内存空间

### 单一连续分配

![单一连续分配](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/单一连续分配.jpeg)


### 固定分区分配

将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一个作业。
有两种策略：
分区大小相等/分区大小不等。

分区大小相等：缺乏灵活性，但是适合用于用一台计算机控制多个相同对象的场合。

分区大小不等：增加灵活性，满足不同大小的进程需求。

如何记录空闲/分配情况：分区说明表，每个表项包括对应分区的大小，起始地址，状态。


优点：简单，无外部碎片

缺点：内部碎片；万一某个用户程序太大，分区不能满足需求


### 动态分区分配

进程装入内存时，根据进程的大小动态建立分区。

1. 操作系统要用什么样的数据结构记录内存的使用情况？

	空闲分区表：分区区号，分区大小，起始地址，分区状态

	空闲分区链：双向链表。每个分区的起始和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息

2. 当很多空闲分区都能满足需求时，应该选择哪个分区进行分配

	动态分区分配算法，

3. 动态分区的回收操作

	合并相邻的空闲分区，新增表项。。。


动态分区分配没有内部碎片，但是有外部碎片

内部碎片：分配给某进程的内存区域，有某些部分没有用上

外部碎片：内存中某些空闲分区由于太小而难以利用。“紧凑技术”


### 动态分区分配算法

![动态分区分配算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法.jpeg)

1. 首次适应算法

	每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

	空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表）

2. 最佳适应算法

	优先使用更小的空闲区。空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链（表），找到能满足大小要求的第一个分区

	缺点：留下很多难以利用的碎片，产生很多外部碎片

3. 最坏适应算法

	又称最大适应算法：为了解决分配留下太多难以利用的小碎片，可以每次都优先使用最大的连续空闲区。

	缺点：每次都利用较大的空闲区，如果后续有大进程到达就没有内存分区可用

4. 临近适应算法

	每次分配查找时都从上次超找结束的位置开始检索，（空闲分区排成循环链表）


比较：

![动态分区分配算法比较](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法比较.jpeg)



## 非连续分配方式：基本分页存储管理

考虑支持多道程序的两种连续分配方式：
固定分区分配，动态分区分配都有缺点。

如果允许将一个进程分散地放入许多不相邻分区，则可以充分利用内存。即“非连续分配方式”，或称为“离散分配方式”。

**基本分页存储管理**，基本分段存储管理，段页式存储管理。

### 基本分页存储管理：

把内存分为一个个相等的小分区，再按照分区大小把进程分成一个个小部分。

内存空间分为的分区称为页框（页帧，内存块，物理块），编号从0开始。页框也不宜过大，否则内部碎片太大。操作系统以页框为单位给各个进程分配空间。

### 如何实现地址转换（物理地址和逻辑地址之间）

1. 页号：除法取整数部分

2. 页内偏移量

3. 页面在内存中的起始位置

4. 物理地址 = 页面地址 + 页内偏移量


### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表

![页表](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页表.jpeg)

每个页表项的长度是相同的，页号是隐含的。（说不明白就不要说）

## 基本地址变换机构

用于实现逻辑地址到物理地址转换的一组硬件结构。可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。

进程未执行时，页表的起始地址和页表长度放在进程控制模块PCB中，进程被调度时，操作系统内核会把它们放到页表寄存器中。

![基本地址变换机构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构.png)

 
![基本地址变换机构总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构总结.png)

## 具有快##表的地址变换结构

### 局部性原理：

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行，如果某个数据被访问后，不久后这个数据很可能会被再次访问

空间局部性：一旦程序访问了某个存储单元，不久之后其附近的存储单元可能也被访问（因为很多数据在内存之中都是连续存放的） 

因此在之前的基本地址变换机构中，可能连续很多次查询同一个页表项

### 快表TLB：

又称**联想寄存器**，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此相对，**内存**中的页表称为慢表。

![快表TLB](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/快表TLB.jpeg)


快表中存放的是页表的一部分副本，若快表命中就不需要再访问内存。

### 引入快表之后，地址的变换过程

![引入快表之后地址的变换过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/引入快表之后地址的变换过程.jpeg)

### 总结







![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.jpeg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.jpg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.JPG)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.png)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.PNG)
































