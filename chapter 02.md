## 2. 第二章 变量和基本类型

### 2.1. 基本内置类型

算数类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算数类型包含字符，整型，布尔值和浮点数。

#### 2.1.1. 算数类型

unsigned 类型所有比特都用来存储值

#### 2.1.2. 类型转换

将对象从一种给定类型convert为另一种相关类型。当我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。、

todo: 算数类型范围，带符号和无符号类型好好整理！！！

例子

```C++
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;       //假设char占8比特，c=255
signed char c2 = 256;       //假设char占8比特，c2的值是未定义的
```

后两个：

+ 当我们赋值给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 -1 mod 256 是255

+ 当我们赋值给带符号类型一个超出他表示范围的值时，结果是未定义的(undefined)，此时程序可能继续工作，可能崩溃也可能生成垃圾数据。

含有无符号类型的表达式

当一个算术表达式中又有int又有无符号数时，这个int就会被转换成无符号数，把int转换成无符号数的过程和把int直接赋值给无符号变量一样

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i + u << std::endl;
    std::cout << i + i << std::endl;
```

这与int在当前机器上所占位数决定，32位：4294967264即 2^32-32。

不要混用带符号类型和无符号类型

练习题！！

#### 2.1.3. 字面值常量literal

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

##### 2.1.3.1. 整形和浮点型字面值

十进制，八进制，十六进制。 以0开头的整数代表八进制，0x或0X开头的代表十六进制。十进制下的20：

20（十进制），024（八进制），0x14（十六进制）

整形字面值具体的数据类型由他的值和符号决定。默认情况下十进制字面值是带符号值，八进制和十六进制字面值既可能是带符号也可能是无符号的。十进制字面值类型是int, long, long long中尺寸最小的那个，前提是能容纳下。八进制和十六进制是int, unsigned int, long, unsigned long, long long, unsigned long long中最小的那个。如果容纳不下，将产生错误。类型short没有对应字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如-42的负十进制字面值，那个符号并不在字面值之内，他的作用是对字面值取负。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用e或E表示，如3.1415e0。

##### 2.1.3.2. 字符和字符串字面值

单引号字符，双引号字符串。 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符('\0')因此，字符串字面值的实际长度比它的内容多1。例如'A'表示单独的字符A，而"A"则代表了一个字符的数组，该数组包含两个字符：一个是字符A，另一个是空字符。

当两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，可以采取分开书写的方式。

##### 2.1.3.3. 转义序列

两类字符不能直接使用，一类是不可打印(nonprintable)的字符，如退格和其他控制字符，因为没有可视的图符。另一类是C++中有特殊含义的，需要转移序列，均由反斜线开始。

##### 2.1.3.4. 制定字面值的类型

通过添加前缀和后缀，可以改变整型，浮点型和字符型的字面值的默认类型。
P37！！！

##### 2.1.3.5. 布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针的字面值。

### 2.2. 变量

变量提供了一个具名的，可供操作的存储空间，C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间存储的值的范围，以及变量能参与的运算，变量variable和对象object一般可互换使用。

对象：具有某种数据类型的内存空间。

#### 2.2.1. 变量定义

类型说明符(type specifier), 随后一个或多个变量名组成的列表，其中变量名以逗号分隔，最终以分号结束。列表中每个变量名的类型都由类型说明符制定，定义时还可以为一个或多个变量定义初始值。在同一条语句中，可以用先定义的变量值去初始化后定义的其他变量

```c++
double price = 109.99, discount = price * 0.16;
```

初始化与赋值的区别：初始化是创建变量时赋予其一个初始值，而赋值的含义是把变量当前值擦除并用新值替代。

##### 2.2.1.1. 列表初始化

花括号初始化变量

```c++
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```

用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

```c++
    long double pi = 3.1415926;
    int a = {pi}, b{pi};            //报错
    int c = (pi), d = pi;           //正确
```

用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。

##### 2.2.1.2. 默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化(default initialized)，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

如果内置类型的变量未被显式初始化，它的值由定义的位置决定，定义于函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，试图拷贝或以其他形式访问此类值将引发错误。

#### 2.2.2. 变量声明和定义的关系

C++允许把程序拆分成多个逻辑部分来编写，支持分离式编译机制，该机制允许将程序分割成若干文件，每个文件可以独立编译。在文件之间共享代码，可能需要在一个文件使用另一个文件中定义的变量。

声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

```c++
    extern int i;       //声明i而非定义i
    int j;              //声明并定义j
```

任何包含了显式初始化的声明即成为定义，可以给由extern关键字标记的变量赋初始值，但是这么做也抵消了extern的作用。extern语句如果包含初始值就不再是声明而是定义了。在函数体内部，如果试图初始化一个extern关键字标记的变量将引发错误。

#### 2.2.3. 标识符

字母数字下划线，对大小写敏感，长度没有限制。C++保留关键字不能做identifier。

#### 2.2.4. 名字的作用域

不论在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量，函数，类型等。然而同一个名字如果出现在程序的不同位置，也可能是指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域都以花括号分隔。

全局作用域，块作用域，嵌套作用域

### 2.3. 复合类型

#### 2.3.1. 引用

“左值引用”，引用为对象起了另外一个名字，引用类型引用(refers to)另外一种类型 通过将声明符写成&d的形式来定义引用类型，其中d是生命的变量名。引用必须被初始化！初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时程序把引用和他的初始值绑定在一起而不是拷贝给引用。引用并非对象，他只是为一个已经存在的对象所起的另外一个名字。
（除了之后两种例外情况）所有引用类型都要和与之绑定的对象严格匹配，而且引用只能绑定在对象上而不能与字面值或某个表达式的计算结果绑定在一起。

```C++
    int &refVal = 10;               //wrong
    double pi = 3.14159;
    int &refVal1 = pi;              //wrong,引用类型的初始值必须也是int型
```

#### 2.3.2. 指针

指针是指向另外一种类型的符合类型。与引用的不同：

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针声明周期内他可以先后指向不同的对象

+ 指针无需在定义时赋初值，和其他内置类型一样，在块作用域中定义的指针如果没有初始化，也将拥有一个不确定的值
  
##### 2.3.2.1. 获取对象的地址

指针存放某个对象的地址，用取地址符获取该地址，指针的类型要和它所指向的对象严格匹配

```C++
    int ival = 42;
    int *p = &ival; //p存放ival的地址，或者说p是指向ival的指针

    double dval;
    double *pd = &dval;     //right
    double *pd2 = pd;       //right

    int *pi = pd;         //false,指针pi类型和pd类型不匹配
    pi = &dval;           //false,试图把double型对象的地址赋给int型指针
```

##### 2.3.2.2. 指针值

！！！！

##### 2.3.2.3. 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象。解引用符只适用于那些却是指向了某个对象的有效指针。注意*和&的多重含义

```C++
    int ival = 42;
    int *p = &ival;
    cout<< *p;

   int i = 42;
   int &r = i;                  //声明中的 引用
   int *p;                      //指针
   p = &i;                      //取地址符
   *p = i;                      //解引用
   int &r2 = *p;                //声明，解引用
```

##### 2.3.2.4. 空指针与初始化指针

！！！！

##### 2.3.2.5. 赋值和指针

##### 2.3.2.6. void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

```C++
    double obj = 3.14, *pd = &obj;
    void *pv = &obj;
    pv = pd;                        //pv可以存放任意类型的指针
```

不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。对void*来说，内存空间也就仅仅是内存空间，没办法访问其中所存的对象。

#### 2.3.3. 理解复合类型的声明

```C++
    int i = 1024, *p = &i, &r=i;
```

在同一条定义语句中，虽然基本数据类型只有一个，但是生命服的形势却可以不同，一条定义语句可以定义出不同类型的变量。

#### 2.3.4. 指向指针的指针

**表示指向指针的指针。

#### 2.3.5. 指向指针的引用

！！！！

### 2.4. const限定符

有时我们希望定义这样一种变量，他的值不能被改变。用关键字const对变量的类型进行限定。

const对象一旦创建之后其值就不能在改变，所以const对象必须初始化，初始值可以是任意表达式。任何试图在之后复制的行为都将会引发错误、

```C++
    const int bufSize = 512;

    bufSize = 512;                  //报错
```

默认状态下，const对象仅在文件内有效。可以在一个文件中定义const，在其他多个文件中声明并使用，应该对于const变量的声明和定义，都添加extern关键字。

#### 2.4.1. const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对敞亮的引用不能被用做修改他说不能绑定的对象。

```C++
    const int ci = 1024;            // right
    const int &rl = ci;             // right
    rl = 42;                        // wrong
    int &r2 = ci;                   // wrong 不能让一个非常量的引用指向一个常量对象
```

！！！

### 2.5. 处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两方面。一是一些类型难于拼写，他们的名字既难记又容易拼错，还无法明确体现其真实目的和含义。二是有时候根本搞不清需要的类型是什么。

#### 2.5.1. 类型别名

类型别名是一个名字，它是某种类型的同义词，他让复杂的类型名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
传统方法是typedef:

```C++
    typedef double wages;           //wages是double的同义词
    typedef wages base, *p;         //base是double的同义词，p是double*的同义词
```

新标准，使用别名声明

```C++
    using SI = Sales_item;          // SI是Sales_item的同义词
```

指针，常量和类型别名：

#### 2.5.2. auto类型说明符

有时在声明变量的时候不能清楚地知道表达式的类型，C++引入auto类型说明符，用它可以让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(如double)不同，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。

#### 2.5.3. decltype类型指示符

### 2.6. 自定义数据结构

#### 定义Sales_data类型

简单的类：用户能直接访问其中的数据元素，也能实现一些基本的操作。不妨命名为Sales_data类：

```C++
struct Sales_data(){
    std::string bookNO;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```

以关键字struct开始，紧跟着类名和类体，类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。类体右侧的表示结束的花括号后必须跟一个分号，这是因为类体后面可以紧跟变量名，以示对该类型对象的定义。不过不被建议

##### 类数据成员

类体定义类的成员，我们这个类只有数据成员，类的数据成员定义了类的对象的具体内容，定义数据成员的方法和定义普通变量一样，首先说明一个基本类型，随后紧跟一个或多个声明符，我们的类有3个数据成员：一个名为bookNo的string成员，etc，每个Sales_data的对象都将包括这三个数据成员。

可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始值得成员将被默认初始化。

#### 使用Sales_data类

##### 添加两个Sales_data对象

在前面介绍的Sales_data类中没有提供任何操作，所以我们必须自己编码实现输入，输出和相加的功能。

##### Sales_data对象写入数据

##### 输出两个Sales_data的和

#### 编写自己的头文件

尽管可以在函数体内定义类，但是这样的类收到了一些限制，所以类一般都不在函数体内。

几个注意事项

##### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器，是在编译之前执行的一段程序，可以部分地改变我们所写的程序。#include是一种预处理功能，当预处理器看到#include 标记时就会用指定的头文件的内容代替#include。

另一种预处理功能是头文件保护符，#define，#ifdef(#endif)。