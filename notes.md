# C++ Primer 笔记

## 1. 第一章 开始

### 1.1. 编写一个简单的C++程序V

多个函数，其中1个必须是main函数。函数四个部分：返回类型，函数名，形参列表，函数体。main函数返回类型必须是int，函数返回值类型必须与函数的返回类型相容。

大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。

### 1.2. 初识输入输出

很多使用iosstream库，isstream和osstream分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语“流stream”想要表达的是，随着时间推移，字符是顺序生成或消耗的。

#### 1.2.1. 标准输入输出对象

4个IO对象，cin：标准输入。cout：标准输出。cerr：输出警告和错误消息，标准错误。clog：用于输出程序运行时的一般性信息。

#### 1.2.2. 一个使用IO库的程序

```C++
#include<iosstream>

int main(){
    std::cout<< "Enter 2 nums" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout<< "v1: "<<v1<<" v2: "<< v2<<std::endl;>
}

```

#### 1.2.3. 向流写入数据

略

#### 1.2.4. 使用标准库中的名字

std的命名空间(namespace)，::是作用域运算符

#### 1.2.5. 从流读取数据

输入运算符>>接收一个istream作为其左侧运算对象

### 1.3. 注释

略

### 1.4. 控制流

#### 1.4.1. while语句

```C++
while(condition)
    statement
```

前缀递增运算符(++i)

#### 1.4.2. for语句

#### 1.4.3. 读取数量不定的输入数据

```C++
#include <iostream>
int main(){
    int sum = 0, value = 0;
    while (std::cin >> value)
        sum += value;
    std::cout<< "sum is: " << sum << std::endl;
    return 0;
}
```

从标准输入读取下一个数，保存在value中。输入运算符返回其左侧运算对象，此例中是std::cin。使用istream对象作为条件时，其效果是检测流的状态，如果流是有效的，未遇到错误，则检测成功。若遇到文件结束符，或遇到无效输入时，istream对象变为无效，无效状态的istream对象会使条件变为假。

#### 1.4.4. if语句

### 1.5. 类简介

在C++中，我们通过定义一个类(class)来定义一个数据结构(data structure)。一个类定义了一个类型，以及与其关联的一组操作。三个问题：类名是什么，在哪里定义的，支持什么操作。

!!!!

## 2. 变量和基本类型

### 2.1. 基本内置类型

算数类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算数类型包含字符，整型，布尔值和浮点数。

#### 2.1.1. 算数类型

unsigned 类型所有比特都用来存储值

#### 2.1.2. 类型转换

将对象从一种给定类型convert为另一种相关类型。当我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。、

todo: 算数类型范围，带符号和无符号类型好好整理！！！

例子

```C++
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;       //假设char占8比特，c=255
signed char c2 = 256;       //假设char占8比特，c2的值是未定义的
```

后两个：

+ 当我们赋值给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 -1 mod 256 是255

+ 当我们赋值给带符号类型一个超出他表示范围的值时，结果是未定义的(undefined)，此时程序可能继续工作，可能崩溃也可能生成垃圾数据。

含有无符号类型的表达式

当一个算术表达式中又有int又有无符号数时，这个int就会被转换成无符号数，把int转换成无符号数的过程和把int直接赋值给无符号变量一样

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i + u << std::endl;
    std::cout << i + i << std::endl;
```

这与int在当前机器上所占位数决定，32位：4294967264即 2^32-32。

不要混用带符号类型和无符号类型

练习题！！

#### 2.1.3. 字面值常量literal

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

##### 2.1.3.1. 整形和浮点型字面值

十进制，八进制，十六进制。 以0开头的整数代表八进制，0x或0X开头的代表十六进制。十进制下的20：

20（十进制），024（八进制），0x14（十六进制）

整形字面值具体的数据类型由他的值和符号决定。默认情况下十进制字面值是带符号值，八进制和十六进制字面值既可能是带符号也可能是无符号的。十进制字面值类型是int, long, long long中尺寸最小的那个，前提是能容纳下。八进制和十六进制是int, unsigned int, long, unsigned long, long long, unsigned long long中最小的那个。如果容纳不下，将产生错误。类型short没有对应字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如-42的负十进制字面值，那个符号并不在字面值之内，他的作用是对字面值取负。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用e或E表示，如3.1415e0。

##### 2.1.3.2. 字符和字符串字面值

单引号字符，双引号字符串。 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符('\0')因此，字符串字面值的实际长度比它的内容多1。例如'A'表示单独的字符A，而"A"则代表了一个字符的数组，该数组包含两个字符：一个是字符A，另一个是空字符。

当两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，可以采取分开书写的方式。

##### 2.1.3.3. 转义序列

两类字符不能直接使用，一类是不可打印(nonprintable)的字符，如退格和其他控制字符，因为没有可视的图符。另一类是C++中有特殊含义的，需要转移序列，均由反斜线开始。

##### 2.1.3.4. 制定字面值的类型

通过添加前缀和后缀，可以改变整型，浮点型和字符型的字面值的默认类型。
P37！！！

##### 2.1.3.5. 布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针的字面值。

### 2.2. 变量

变量提供了一个具名的，可供操作的存储空间，C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间存储的值的范围，以及变量能参与的运算，变量variable和对象object一般可互换使用。

对象：具有某种数据类型的内存空间。

#### 2.2.1. 变量定义

类型说明符(type specifier), 随后一个或多个变量名组成的列表，其中变量名以逗号分隔，最终以分号结束。列表中每个变量名的类型都由类型说明符制定，定义时还可以为一个或多个变量定义初始值。在同一条语句中，可以用先定义的变量值去初始化后定义的其他变量

```c++
double price = 109.99, discount = price * 0.16;
```

初始化与赋值的区别：初始化是创建变量时赋予其一个初始值，而赋值的含义是把变量当前值擦除并用新值替代。

##### 2.2.1.1. 列表初始化

花括号初始化变量

```c++
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```

用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

```c++
    long double pi = 3.1415926;
    int a = {pi}, b{pi};            //报错
    int c = (pi), d = pi;           //正确
```

用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。

##### 2.2.1.2. 默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化(default initialized)，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

如果内置类型的变量未被显式初始化，它的值由定义的位置决定，定义于函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，试图拷贝或以其他形式访问此类值将引发错误。

#### 2.2.2. 变量声明和定义的关系

C++允许把程序拆分成多个逻辑部分来编写，支持分离式编译机制，该机制允许将程序分割成若干文件，每个文件可以独立编译。在文件之间共享代码，可能需要在一个文件使用另一个文件中定义的变量。

声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

```c++
    extern int i;       //声明i而非定义i
    int j;              //声明并定义j
```

任何包含了显式初始化的声明即成为定义，可以给由extern关键字标记的变量赋初始值，但是这么做也抵消了extern的作用。extern语句如果包含初始值就不再是声明而是定义了。在函数体内部，如果试图初始化一个extern关键字标记的变量将引发错误。

#### 2.2.3. 标识符

字母数字下划线，对大小写敏感，长度没有限制。C++保留关键字不能做identifier。

#### 2.2.4. 名字的作用域

不论在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量，函数，类型等。然而同一个名字如果出现在程序的不同位置，也可能是指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域都以花括号分隔。

全局作用域，块作用域，嵌套作用域

### 2.3. 复合类型

#### 2.3.1. 引用

“左值引用”，引用为对象起了另外一个名字，引用类型引用(refers to)另外一种类型 通过将声明符写成&d的形式来定义引用类型，其中d是生命的变量名。引用必须被初始化！初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时程序把引用和他的初始值绑定在一起而不是拷贝给引用。引用并非对象，他只是为一个已经存在的对象所起的另外一个名字。
（除了之后两种例外情况）所有引用类型都要和与之绑定的对象严格匹配，而且引用只能绑定在对象上而不能与字面值或某个表达式的计算结果绑定在一起。

```C++
    int &refVal = 10;               //wrong
    double pi = 3.14159;
    int &refVal1 = pi;              //wrong,引用类型的初始值必须也是int型
```

#### 2.3.2. 指针

指针是指向另外一种类型的符合类型。与引用的不同：

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针声明周期内他可以先后指向不同的对象

+ 指针无需在定义时赋初值，和其他内置类型一样，在块作用域中定义的指针如果没有初始化，也将拥有一个不确定的值
  
##### 2.3.2.1. 获取对象的地址

指针存放某个对象的地址，用取地址符获取该地址，指针的类型要和它所指向的对象严格匹配

```C++
    int ival = 42;
    int *p = &ival; //p存放ival的地址，或者说p是指向ival的指针

    double dval;
    double *pd = &dval;     //right
    double *pd2 = pd;       //right

    int *pi = pd;         //false,指针pi类型和pd类型不匹配
    pi = &dval;           //false,试图把double型对象的地址赋给int型指针
```

##### 2.3.2.2. 指针值

！！！！

##### 2.3.2.3. 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象。解引用符只适用于那些却是指向了某个对象的有效指针。注意*和&的多重含义

```C++
    int ival = 42;
    int *p = &ival;
    cout<< *p;

   int i = 42;
   int &r = i;                  //声明中的 引用
   int *p;                      //指针
   p = &i;                      //取地址符
   *p = i;                      //解引用
   int &r2 = *p;                //声明，解引用
```

##### 2.3.2.4. 空指针与初始化指针

！！！！

##### 2.3.2.5. 赋值和指针

##### 2.3.2.6. void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

```C++
    double obj = 3.14, *pd = &obj;
    void *pv = &obj;
    pv = pd;                        //pv可以存放任意类型的指针
```

不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。对void*来说，内存空间也就仅仅是内存空间，没办法访问其中所存的对象。

#### 2.3.3. 理解复合类型的声明

```C++
    int i = 1024, *p = &i, &r=i;
```

在同一条定义语句中，虽然基本数据类型只有一个，但是生命服的形势却可以不同，一条定义语句可以定义出不同类型的变量。

#### 2.3.4. 指向指针的指针

**表示指向指针的指针。

#### 2.3.5. 指向指针的引用

！！！！

### 2.4. const限定符

有时我们希望定义这样一种变量，他的值不能被改变。用关键字const对变量的类型进行限定。

const对象一旦创建之后其值就不能在改变，所以const对象必须初始化，初始值可以是任意表达式。任何试图在之后复制的行为都将会引发错误、

```C++
    const int bufSize = 512;

    bufSize = 512;                  //报错
```

默认状态下，const对象仅在文件内有效。可以在一个文件中定义const，在其他多个文件中声明并使用，应该对于const变量的声明和定义，都添加extern关键字。

#### 2.4.1. const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对敞亮的引用不能被用做修改他说不能绑定的对象。

```C++
    const int ci = 1024;            // right
    const int &rl = ci;             // right
    rl = 42;                        // wrong
    int &r2 = ci;                   // wrong 不能让一个非常量的引用指向一个常量对象
```

！！！

### 2.5. 处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两方面。一是一些类型难于拼写，他们的名字既难记又容易拼错，还无法明确体现其真实目的和含义。二是有时候根本搞不清需要的类型是什么。

#### 2.5.1. 类型别名

类型别名是一个名字，它是某种类型的同义词，他让复杂的类型名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
传统方法是typedef:

```C++
    typedef double wages;           //wages是double的同义词
    typedef wages base, *p;         //base是double的同义词，p是double*的同义词
```

新标准，使用别名声明

```C++
    using SI = Sales_item;          // SI是Sales_item的同义词
```

指针，常量和类型别名：

#### 2.5.2. auto类型说明符

有时在声明变量的时候不能清楚地知道表达式的类型，C++引入auto类型说明符，用它可以让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(如double)不同，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。

#### 2.5.3. decltype类型指示符

### 2.6. 自定义数据结构

## 3. 字符串，向量和数组

标准库类型string，vector，数组。

### 3.1. 命名空间的using声明

作用域操作符(::)：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。using声明：通过更简单的途径使用到命名空间中的成员。形式是

```C++
    using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间中的名字。但是每个名字都要独立的using声明。

```C++
#include <iostream>

using std::cin;

int main(){
    int i;
    cin >> i;           //right
    cout << i;          //wrong 没有对应的using声明
    std::cout<<i;       //right
    return 0;
}
```

头文件不应包含using声明，因为头文件的内容会拷贝到所有引用他的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个生命，可能会造成名字冲突。

### 3.2. 标准库类型string

使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。

```C++
#include <string>
using std::string;
```

#### 3.2.1. 定义和初始化string对象

几种初始化string对象的方式，直接初始化不用'='，复制初始化用'。

```C++
    string s1;
    string s2 = s1;
    string s3 = "hiya";
    string s4(10,'c');            //10个c
    string s5(s1);
    string s6("hiya");
```

#### 3.2.2. string对象上的操作

常用操作

+ os<<s
+ is>>s
+ getline(is, s)                        //从is中读取一行赋给s，返回is
+ s.empty(), s.size();
+ s[n]
+ s1+s2, s1=s2, s1==s2, s1!=s2
+ <,>,<=,>=

读写string对象，可以用IO操作符读写string对象：

```C++
int main(){
    string s;
    cin >> s;
    cout<<s<<endl;

    return 0;
}
```

如果程序输入的是"   Hello World",输出是"Hello"。输出结果没有空格。

```C++
    string s1,s2;
    cin >> s1 >> s2;
    cout<< s1 << s2 << endl;
```

输入"   Hello World"，输出"HelloWorld"。

```C++
int main(){
    string world;
    while(cin >> word)
        cout << word << endl;
    return 0;
}
```

读取未知数量的string对象。

```C++
int main(){
    string line;
    while(getline(cin,line))
        cout<< line <<endl;
    return 0;
}
```

有时我们希望在最终得到的字符串中保留输入时的空白符。getline从给定的输入流中读入内容，直到遇到换行符为止。

##### 3.2.2.1. string的.empty()和.size()

empty操作

```C++
    while(getline(cin,line))
        if(!line.empty())
            cout << line << endl;
```

size操作

```C++
    while(getline(cin, line))
        if(line.size() > 80)
            cout << line << endl;
```

##### 3.2.2.2. string::size_type 类型

.size()返回一个string::size_type类型的值。是一个无符号整型数，因此如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。

```C++
int main() {
    string str("abc");
    int a = -3;
    if(str.size() < a){
        std::cout<<"Why is here?"<<std::endl;
    }
    return 0;
}
```

##### 3.2.2.3. 比较string对象

##### string对象相加

标准库中允许把字符字面值和字符串字面值。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。

#### 3.2.3. 处理string对象中的字符

cctype头文件。

### 标准库类型vector

vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象，因为vector容纳着其他对象，所以它也常被称作容器。vector是一个类模板，16章学习自定义模板。
模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化。

## 4. 表达式

## 5. 语句

## 6. 函数

## 7. 类

## 8. IO库

## 9. 顺序容器

## 10. 泛型算法

## 11. 关联容器

## 12. 动态内存

## 13. 拷贝控制

## 14. 重载运算与类型转换

## 15. 面向对象的程序设计

## 16. 模板与泛型编程

## 17. references

    习题参考解答 <https://github.com/applenob/Cpp_Primer_Practice>
