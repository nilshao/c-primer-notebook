# C++ Primer 笔记

## 1. 第一章 开始

### 1.1. 编写一个简单的C++程序V

多个函数，其中1个必须是main函数。函数四个部分：返回类型，函数名，形参列表，函数体。main函数返回类型必须是int，函数返回值类型必须与函数的返回类型相容。

大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。

### 1.2. 初识输入输出

很多使用iosstream库，isstream和osstream分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语“流stream”想要表达的是，随着时间推移，字符是顺序生成或消耗的。

#### 1.2.1. 标准输入输出对象

4个IO对象，cin：标准输入。cout：标准输出。cerr：输出警告和错误消息，标准错误。clog：用于输出程序运行时的一般性信息。

#### 1.2.2. 一个使用IO库的程序

```C++
#include<iosstream>

int main(){
    std::cout<< "Enter 2 nums" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout<< "v1: "<<v1<<" v2: "<< v2<<std::endl;>
}

```

#### 1.2.3. 向流写入数据

略

#### 1.2.4. 使用标准库中的名字

std的命名空间(namespace)，::是作用域运算符

#### 1.2.5. 从流读取数据

输入运算符>>接收一个istream作为其左侧运算对象

### 1.3. 注释

略

### 1.4. 控制流

#### 1.4.1. while语句

```C++
while(condition)
    statement
```

前缀递增运算符(++i)

#### 1.4.2. for语句

#### 1.4.3. 读取数量不定的输入数据

```C++
#include <iostream>
int main(){
    int sum = 0, value = 0;
    while (std::cin >> value)
        sum += value;
    std::cout<< "sum is: " << sum << std::endl;
    return 0;
}
```

从标准输入读取下一个数，保存在value中。输入运算符返回其左侧运算对象，此例中是std::cin。使用istream对象作为条件时，其效果是检测流的状态，如果流是有效的，未遇到错误，则检测成功。若遇到文件结束符，或遇到无效输入时，istream对象变为无效，无效状态的istream对象会使条件变为假。

#### 1.4.4. if语句

### 1.5. 类简介

在C++中，我们通过定义一个类(class)来定义一个数据结构(data structure)。一个类定义了一个类型，以及与其关联的一组操作。三个问题：类名是什么，在哪里定义的，支持什么操作。

!!!!

## 2. 变量和基本类型

### 2.1. 基本内置类型

算数类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算数类型包含字符，整型，布尔值和浮点数。

#### 2.1.1. 算数类型

unsigned 类型所有比特都用来存储值

#### 2.1.2. 类型转换

将对象从一种给定类型convert为另一种相关类型。当我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。、

todo: 算数类型范围，带符号和无符号类型好好整理！！！

例子

```C++
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;       //假设char占8比特，c=255
signed char c2 = 256;       //假设char占8比特，c2的值是未定义的
```

后两个：

+ 当我们赋值给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数 -1 mod 256 是255

+ 当我们赋值给带符号类型一个超出他表示范围的值时，结果是未定义的(undefined)，此时程序可能继续工作，可能崩溃也可能生成垃圾数据。

含有无符号类型的表达式

当一个算术表达式中又有int又有无符号数时，这个int就会被转换成无符号数，把int转换成无符号数的过程和把int直接赋值给无符号变量一样

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i + u << std::endl;
    std::cout << i + i << std::endl;
```

这与int在当前机器上所占位数决定，32位：4294967264即 2^32-32。

不要混用带符号类型和无符号类型

练习题！！

#### 2.1.3. 字面值常量literal

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

##### 2.1.3.1. 整形和浮点型字面值

十进制，八进制，十六进制。 以0开头的整数代表八进制，0x或0X开头的代表十六进制。十进制下的20：

20（十进制），024（八进制），0x14（十六进制）

整形字面值具体的数据类型由他的值和符号决定。默认情况下十进制字面值是带符号值，八进制和十六进制字面值既可能是带符号也可能是无符号的。十进制字面值类型是int, long, long long中尺寸最小的那个，前提是能容纳下。八进制和十六进制是int, unsigned int, long, unsigned long, long long, unsigned long long中最小的那个。如果容纳不下，将产生错误。类型short没有对应字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如-42的负十进制字面值，那个符号并不在字面值之内，他的作用是对字面值取负。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用e或E表示，如3.1415e0。

##### 2.1.3.2. 字符和字符串字面值

单引号字符，双引号字符串。 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符('\0')因此，字符串字面值的实际长度比它的内容多1。例如'A'表示单独的字符A，而"A"则代表了一个字符的数组，该数组包含两个字符：一个是字符A，另一个是空字符。

当两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，可以采取分开书写的方式。

##### 2.1.3.3. 转义序列

两类字符不能直接使用，一类是不可打印(nonprintable)的字符，如退格和其他控制字符，因为没有可视的图符。另一类是C++中有特殊含义的，需要转移序列，均由反斜线开始。

##### 2.1.3.4. 制定字面值的类型

通过添加前缀和后缀，可以改变整型，浮点型和字符型的字面值的默认类型。
P37！！！

##### 2.1.3.5. 布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针的字面值。

### 2.2. 变量

变量提供了一个具名的，可供操作的存储空间，C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间存储的值的范围，以及变量能参与的运算，变量variable和对象object一般可互换使用。

对象：具有某种数据类型的内存空间。

#### 2.2.1. 变量定义

类型说明符(type specifier), 随后一个或多个变量名组成的列表，其中变量名以逗号分隔，最终以分号结束。列表中每个变量名的类型都由类型说明符制定，定义时还可以为一个或多个变量定义初始值。在同一条语句中，可以用先定义的变量值去初始化后定义的其他变量

```c++
double price = 109.99, discount = price * 0.16;
```

初始化与赋值的区别：初始化是创建变量时赋予其一个初始值，而赋值的含义是把变量当前值擦除并用新值替代。

##### 2.2.1.1. 列表初始化

花括号初始化变量

```c++
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```

用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

```c++
    long double pi = 3.1415926;
    int a = {pi}, b{pi};            //报错
    int c = (pi), d = pi;           //正确
```

用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。

##### 2.2.1.2. 默认初始化

如果定义变量时没有指定初始值，则变量被默认初始化(default initialized)，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

如果内置类型的变量未被显式初始化，它的值由定义的位置决定，定义于函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，试图拷贝或以其他形式访问此类值将引发错误。

#### 2.2.2. 变量声明和定义的关系

C++允许把程序拆分成多个逻辑部分来编写，支持分离式编译机制，该机制允许将程序分割成若干文件，每个文件可以独立编译。在文件之间共享代码，可能需要在一个文件使用另一个文件中定义的变量。

声明和定义区分开，声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

```c++
    extern int i;       //声明i而非定义i
    int j;              //声明并定义j
```

任何包含了显式初始化的声明即成为定义，可以给由extern关键字标记的变量赋初始值，但是这么做也抵消了extern的作用。extern语句如果包含初始值就不再是声明而是定义了。在函数体内部，如果试图初始化一个extern关键字标记的变量将引发错误。

#### 2.2.3. 标识符

字母数字下划线，对大小写敏感，长度没有限制。C++保留关键字不能做identifier。

#### 2.2.4. 名字的作用域

不论在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量，函数，类型等。然而同一个名字如果出现在程序的不同位置，也可能是指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域都以花括号分隔。

全局作用域，块作用域，嵌套作用域

### 2.3. 复合类型

#### 2.3.1. 引用

“左值引用”，引用为对象起了另外一个名字，引用类型引用(refers to)另外一种类型 通过将声明符写成&d的形式来定义引用类型，其中d是生命的变量名。引用必须被初始化！初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时程序把引用和他的初始值绑定在一起而不是拷贝给引用。引用并非对象，他只是为一个已经存在的对象所起的另外一个名字。
（除了之后两种例外情况）所有引用类型都要和与之绑定的对象严格匹配，而且引用只能绑定在对象上而不能与字面值或某个表达式的计算结果绑定在一起。

```C++
    int &refVal = 10;               //wrong
    double pi = 3.14159;
    int &refVal1 = pi;              //wrong,引用类型的初始值必须也是int型
```

#### 2.3.2. 指针

指针是指向另外一种类型的符合类型。与引用的不同：

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针声明周期内他可以先后指向不同的对象

+ 指针无需在定义时赋初值，和其他内置类型一样，在块作用域中定义的指针如果没有初始化，也将拥有一个不确定的值
  
##### 2.3.2.1. 获取对象的地址

指针存放某个对象的地址，用取地址符获取该地址，指针的类型要和它所指向的对象严格匹配

```C++
    int ival = 42;
    int *p = &ival; //p存放ival的地址，或者说p是指向ival的指针

    double dval;
    double *pd = &dval;     //right
    double *pd2 = pd;       //right

    int *pi = pd;         //false,指针pi类型和pd类型不匹配
    pi = &dval;           //false,试图把double型对象的地址赋给int型指针
```

##### 2.3.2.2. 指针值

！！！！

##### 2.3.2.3. 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象。解引用符只适用于那些却是指向了某个对象的有效指针。注意*和&的多重含义

```C++
    int ival = 42;
    int *p = &ival;
    cout<< *p;

   int i = 42;
   int &r = i;                  //声明中的 引用
   int *p;                      //指针
   p = &i;                      //取地址符
   *p = i;                      //解引用
   int &r2 = *p;                //声明，解引用
```

##### 2.3.2.4. 空指针与初始化指针

！！！！

##### 2.3.2.5. 赋值和指针

##### 2.3.2.6. void* 指针

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

```C++
    double obj = 3.14, *pd = &obj;
    void *pv = &obj;
    pv = pd;                        //pv可以存放任意类型的指针
```

不能直接操作void*指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。对void*来说，内存空间也就仅仅是内存空间，没办法访问其中所存的对象。

#### 2.3.3. 理解复合类型的声明

```C++
    int i = 1024, *p = &i, &r=i;
```

在同一条定义语句中，虽然基本数据类型只有一个，但是生命服的形势却可以不同，一条定义语句可以定义出不同类型的变量。

#### 2.3.4. 指向指针的指针

**表示指向指针的指针。

#### 2.3.5. 指向指针的引用

！！！！

### 2.4. const限定符

有时我们希望定义这样一种变量，他的值不能被改变。用关键字const对变量的类型进行限定。

const对象一旦创建之后其值就不能在改变，所以const对象必须初始化，初始值可以是任意表达式。任何试图在之后复制的行为都将会引发错误、

```C++
    const int bufSize = 512;

    bufSize = 512;                  //报错
```

默认状态下，const对象仅在文件内有效。可以在一个文件中定义const，在其他多个文件中声明并使用，应该对于const变量的声明和定义，都添加extern关键字。

#### 2.4.1. const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对敞亮的引用不能被用做修改他说不能绑定的对象。

```C++
    const int ci = 1024;            // right
    const int &rl = ci;             // right
    rl = 42;                        // wrong
    int &r2 = ci;                   // wrong 不能让一个非常量的引用指向一个常量对象
```

！！！

### 2.5. 处理类型

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两方面。一是一些类型难于拼写，他们的名字既难记又容易拼错，还无法明确体现其真实目的和含义。二是有时候根本搞不清需要的类型是什么。

#### 2.5.1. 类型别名

类型别名是一个名字，它是某种类型的同义词，他让复杂的类型名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
传统方法是typedef:

```C++
    typedef double wages;           //wages是double的同义词
    typedef wages base, *p;         //base是double的同义词，p是double*的同义词
```

新标准，使用别名声明

```C++
    using SI = Sales_item;          // SI是Sales_item的同义词
```

指针，常量和类型别名：

#### 2.5.2. auto类型说明符

有时在声明变量的时候不能清楚地知道表达式的类型，C++引入auto类型说明符，用它可以让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(如double)不同，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。

#### 2.5.3. decltype类型指示符

### 2.6. 自定义数据结构

## 3. 字符串，向量和数组

标准库类型string，vector，数组。

### 3.1. 命名空间的using声明

作用域操作符(::)：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。using声明：通过更简单的途径使用到命名空间中的成员。形式是

```C++
    using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间中的名字。但是每个名字都要独立的using声明。

```C++
#include <iostream>

using std::cin;

int main(){
    int i;
    cin >> i;           //right
    cout << i;          //wrong 没有对应的using声明
    std::cout<<i;       //right
    return 0;
}
```

头文件不应包含using声明，因为头文件的内容会拷贝到所有引用他的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个生命，可能会造成名字冲突。

### 3.2. 标准库类型string

使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。

```C++
#include <string>
using std::string;
```

#### 3.2.1. 定义和初始化string对象

几种初始化string对象的方式，直接初始化不用'='，复制初始化用'。

```C++
    string s1;
    string s2 = s1;
    string s3 = "hiya";
    string s4(10,'c');            //10个c
    string s5(s1);
    string s6("hiya");
```

#### 3.2.2. string对象上的操作

常用操作

+ os<<s
+ is>>s
+ getline(is, s)                        //从is中读取一行赋给s，返回is
+ s.empty(), s.size();
+ s[n]
+ s1+s2, s1=s2, s1==s2, s1!=s2
+ <,>,<=,>=

读写string对象，可以用IO操作符读写string对象：

```C++
int main(){
    string s;
    cin >> s;
    cout<<s<<endl;

    return 0;
}
```

如果程序输入的是"   Hello World",输出是"Hello"。输出结果没有空格。

```C++
    string s1,s2;
    cin >> s1 >> s2;
    cout<< s1 << s2 << endl;
```

输入"   Hello World"，输出"HelloWorld"。

```C++
int main(){
    string world;
    while(cin >> word)
        cout << word << endl;
    return 0;
}
```

读取未知数量的string对象。

```C++
int main(){
    string line;
    while(getline(cin,line))
        cout<< line <<endl;
    return 0;
}
```

有时我们希望在最终得到的字符串中保留输入时的空白符。getline从给定的输入流中读入内容，直到遇到换行符为止。

##### 3.2.2.1. string的.empty()和.size()

empty操作

```C++
    while(getline(cin,line))
        if(!line.empty())
            cout << line << endl;
```

size操作

```C++
    while(getline(cin, line))
        if(line.size() > 80)
            cout << line << endl;
```

##### 3.2.2.2. string::size_type 类型

.size()返回一个string::size_type类型的值。是一个无符号整型数，因此如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。

```C++
int main() {
    string str("abc");
    int a = -3;
    if(str.size() < a){
        std::cout<<"Why is here?"<<std::endl;
    }
    return 0;
}
```

##### 3.2.2.3. 比较string对象

##### 3.2.2.4. string对象相加

标准库中允许把字符字面值和字符串字面值。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。

#### 3.2.3. 处理string对象中的字符

cctype头文件。

### 3.3. 标准库类型vector

vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象，因为vector容纳着其他对象，所以它也常被称作容器。vector是一个类模板，16章学习自定义模板。
模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化。

对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定，在模板名字后面跟一对尖括号，在括号内放上信息。

vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>. vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。

#### 3.3.1. 定义和初始化vector对象

可以初始化空vector对象，也可以指定初始值。

##### 3.3.1.1. 列表初始化

用花括号进行初始化。

##### 3.3.1.2. 创建指定数量的元素

```C++
    vector<int> ivec(10,-1);
    vector<string> svec(10,"hi~");
```

##### 3.3.1.3. 值初始化

特殊限制：1. 有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。2.如果只提供了元素的数量而没有设定初始值，则只能使用直接初始化。

##### 3.3.1.4. 列表初始值还是元素数量

初始化的真实含义取决于传递初始值时用的是花括号还是圆括号。如果是圆括号，啧可以说提供的值是用来构造vector对象的。如果是花括号，可以表述成我们想列表初始化该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。

#### 3.3.2. 向vector中添加元素

#### 3.3.3. 其他vector操作

### 3.4. 迭代器介绍

#### 3.4.1. 使用迭代器

string和vector支持迭代器，有迭代器的类型同时拥有返回迭代器的成员，比如begin和end，end成员负责返回指向容器“尾部的下一个位置”，也就是说，该迭代器指示的是容器的一个并不存在的“尾后”元素，也称为尾后迭代器，如果容器为空，则begin和end返回同一个迭代器。

##### 3.4.1.1. 迭代器运算符

可以使用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，否则不相等。

+ *iter 返回迭代器iter所指元素的引用
+ iter->mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
+ ++iter 令iter指示容器中的下一个元素
+ --iter 令iter只是容器中的上一个元素
+ iter1 == iter2, iter1 != iter2
  
1. 通过解引用迭代器来获取他所指的元素

```C++
    string s("some string");
    if(s.begin() != s.end()){
        auto it = s.begin();
        *it = toubpper(*it);
    }
```

2. 将迭代器从一个元素移动到另外一个元素

递增运算符，递减运算符，来实现向前移动一个位置，向后移动一个位置。

```C++
    for(auto it = s.begin(); it!=s.end() && !isspace(*it); ++it){
        *it = toupper(*it);
    }
```

##### 3.4.1.2. 迭代器类型

迭代器的标准库类型用iterator和const_iterator来表示迭代器类型。

```C++
    vector<int>::iterator it;
    string::iterator it2;

    vector<int>::const_iterator it3;
    string::const_iterator it4;
```

cbegin????

##### 3.4.1.3. 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如对于一个有字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了

```C++
    (*it).empty();
```

圆括号必不可少，因为先对it解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由it执行而非it解引用的结果。
为了简化上述表达式，C++定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem等价于(*it).mem的表达意思。例如：

```C++
    for(auto it = text.begin(); it != text.cend() && !it->empty(); ++it)
        cout<< *it << endl;
```

##### 3.4.1.4. 某些对vetor对象的操作会使迭代器失效

vector对象可以动态的增长，但是也有一些副作用，一个是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使vector对象的迭代器失效。

#### 3.4.2. 迭代器运算

##### 3.4.2.1. 迭代器的算数运算

可以令迭代器和一个整数值相加或相减，其返回值是向前或向后移动了若干个位置的迭代器。执行这样的操作时，结果迭代器或者指示原vector对象内的一个元素，或者指示原vector对象尾元素的下一个位置。对于string或vector的迭代器来说，除了判断是否相等，还可以用关系运算符(<,>,<=,>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器内的元素或者为元素的下一个位置。只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所的结果是两个迭代器的距离。带符号整型数，可正可负。

##### 3.4.2.2. 使用迭代器运算

例子：二分搜索

```C++
    auto beg = text.begin(), end = text.end();
    auto mid = text.begin() + (end-beg) / 2;

    while(mid != end && *mid != target){
        if(target < *mid)
            end = mid;
        else
            begin = mid+1;
        mid = beg + (end - beg) / 2;
    }
```

### 3.5. 数组

数组是一种类似于vector的数据结构，但是在性能和灵活性上与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置进行访问。与vector不同的地方是，数组大小确定不变，不能随意的向数组中增加元素。因为数组的大小固定，因此对某些特定应用情形来说性能更好，但也失去一些灵活性。如果不确定元素的确切个数，使用vector。

#### 3.5.1. 定义和初始化内置数组

维度必须是一个常量表达式！！！

```C++
    unsigned cnt = 42;                      // 不是常量表达式
    constexpr unsigned sz = 42;             // 常量表达式
    int arr[10];
    int *parr[sz];                          //ok!
    string bad[cnt];                        //cnt不是常量表达式！
```

##### 3.5.1.1. 显式初始化数组元素

可以对数组元素进行列表初始化，此时允许忽略数组的维度，如果在声明时没有指定维度，编译器会根据初始值的数量计算并推测出来。相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。

##### 3.5.1.2. 字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化，当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。

```C++
    char a1[] = {'C','+','+'};
    char a2[] = {'C','+','+','\0'};
    char a3[] = "C++";
    char a4[3] = "C++";                     //错误！没有空间存放空字符
```

##### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```C++
    int a[] = {0,1,2};
    int a2[] = a;               //错误：不允许使用一个数组初始化另一个数组
    a2 = a;                     //错误：不能把一个数组直接赋值给另一个数组
```

## 4. 表达式

### 4.1. 基础

#### 4.1.1. 基本概念

一元运算符，二元运算符：作用于一个运算对象的运算符是一元运算符，作用于两个运算对象的运算符是二元运算符，也有三元运算符。函数调用也是一种特殊运算符，他对运算对象的数量没有限制。一些符号即可以作为一元运算符也可以作为二元运算符，如*既可以作为一元运算符执行解引用操作，作为二元运算符时执行乘法操作。

##### 运算对象转换

##### 重载运算符

C++定义了运算符作用于内置类型和符合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另一层含义，所以称之为重载运算符。

##### 左值和右值

#### 4.1.2. 求值顺序

### 4.2. 算术运算符

#### 4.2.1. 优先级和结合律

### 4.3. 逻辑关系运算符

### 4.4. 赋值运算符

不要混淆相等运算符和赋值运算符

```C++
    if(i = j)
```

此时if语句的条件部分把j的值赋给i，然后检查赋值结果是否为真。如果j不是0，条件将为真。

### 4.5. 递增和递减运算符

递增运算符(++)和递减运算符(--)这两个运算符可以为对象加1或减1，也可以应用于迭代器，因为很多迭代器本身不支持算数运算。递增递减有前置版本和后置版本，前置版本的运算符首先将运算对象加1或减1，然后将改变后的对象作为求值结果。后置版本会将运算对象加一，但是求值结果是运算对象改变之前的那个值的副本。

##### 在一条语句中混用解引用和递增运算符

如果我们想在一条复合表达式中既将变量+1或-1又能使用他原来的值，这时就可以使用递增和递减运算符的后置版本。后置递增运算符的优先级高于解引用运算符。

```C++
    int i = 0, j;
    j = ++i;            //j = 1; i = 1;
//或
    j = i++;            //j = 1; i = 2;
```

##### 运算对象可按任意顺序求值

### 成员访问运算符

点运算符和箭头运算符都可用于访问成员，其中点运算符获取类对象的一个成员：箭头运算符与点运算符相关。ptr->mem等价于(*ptr).mem。因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。

### 条件运算符

条件运算符(?:)允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用。

```C++
    cond ? expr1 : expr2;
```

首先求cond的值，如果条件为真时对expr1求值并返回该值，否则对expr2求值并返回该值。

```C++
    string finalgrade = (grade < 60) ? "fail" : "pass";
```

##### 嵌套条件运算符

允许在条件运算符的内部嵌套另外一个条件运算符。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。举个例子，使用嵌套条件运算符可以将成绩分成三档：优秀，合格，和不合格。

```C++
    finalgrade = (grade > 90) ? "high pass" :(grade < 60) ? "fail" : "pass";
```

##### 在输出表达式中使用条件运算符

### 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。

##### 移位运算符

之前在处理输入和输出操作时，我们已经使用过标准IO库定义的<<运算符和>>运算符的重载版本。这两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移或者向右移，移出边界外的位就被舍弃掉了。

左移运算符(<<)在右侧插入值为0的二进制位。右移运算符的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位，如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

##### 位求反运算符

位求反运算符(~)将运算对象逐位求反后生成一个新值。char类型的运算对象首先提升为int类型，提升时运算对象原来的位保持不变，往高位添加0即可。因此在本例中，首先将bits提升成int类型，增加24个高位0，随后将提升后的值逐位求反。

## 5. 语句

## 6. 函数

## 7. 类

## 8. IO库

## 9. 顺序容器

## 10. 泛型算法

## 11. 关联容器

## 12. 动态内存

## 13. 拷贝控制

## 14. 重载运算与类型转换

## 15. 面向对象的程序设计

## 16. 模板与泛型编程

## 17. references

    习题参考解答 <https://github.com/applenob/Cpp_Primer_Practice>
